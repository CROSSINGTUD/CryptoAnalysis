{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to the Documentation of CogniCrypt<sub>SAST</sub>","text":"<p>CogniCrypt<sub>SAST</sub> is the static analysis component for CogniCrypt. It takes a set of rules written in the specification language CrySL as input, performs a static analysis based on these specifications and creates a report with all violations.</p> <p>CogniCrypt<sub>SAST</sub> provides the following features:</p> <ul> <li>A context-sensitive, field-sensitive and flow-sensitive typestate analysis using IDEal</li> <li>A context-sensitive, field-sensitive and flow-sensitive pointer analysis using Boomerang</li> <li>A CLI and API to analyze Java and Android applications</li> <li>Support for the static analysis frameworks Soot, SootUp and Opal</li> <li>A wide range of different error types that explain the violations of CrySL specifications</li> <li>An API to configure your own analysis</li> </ul> <p>This documentation covers the following aspects:</p> <ul> <li>The installation and setup for the project</li> <li>A tutorial on how to use CongiCrypt<sub>SAST</sub> for Java and Android applications</li> <li>A list with examples for all reported error types</li> <li>Examples of running CogniCrypt<sub>SAST</sub> with a Java application</li> <li>A description of the API that allows the extension of CogniCrypt<sub>SAST</sub></li> <li>Information about contributing to this project</li> </ul>"},{"location":"android-scanner/","title":"CogniCrypt<sub>SAST</sub> for Android Applications","text":"<p>The <code>HeadlessAndroidScanner</code> implements an interface for CogniCrypt<sub>SAST</sub> that allows the analysis of Android applications. You can use it as an CLI tool or run it programmatically with a dependency.</p>"},{"location":"android-scanner/#headlessandroidscanner-as-cli-tool","title":"HeadlessAndroidScanner as CLI tool","text":"<p>CogniCrypt<sub>SAST</sub> can be started as CLI tool via the file <code>HeadlessAndroidScanner-x.y.z-jar-with-dependencies.jar</code>. You can build this file yourself (see the installation) or download the last released version from the GitHub releases. The following list explains required and optional CLI options. See the examples for concrete use cases</p>"},{"location":"android-scanner/#required-options","title":"Required options","text":"<p>The HeadlessJavaScanner requires three arguments:</p> <ul> <li> <p>--apkFile &lt;path_to_apk_file&gt;</p> <p>The path of the apk file to be analyzed.</p> </li> <li> <p>--platformDirectory &lt;path_to_platform_dir&gt;</p> <p>The path to the android SDK platforms. The platforms are obtainable via Android Studio. Under the Android SDK location you find a folder <code>platforms</code>. Supply the <code>HeadlessAndroidScanner</code> with the path to this folder.</p> </li> <li> <p>--rulesDir &lt;path_to_rules&gt;</p> <p>The path to the directory of the CrySL (source code format) rule files. The scanner supports basic directories and zip files. The source code for the rules can be found here.</p> </li> </ul>"},{"location":"android-scanner/#optional-arguments","title":"Optional arguments","text":"<ul> <li> <p>--cg &lt;call_graph&gt;</p> <p>The call graph algorithm to construct the call graph for the analysis. Possible values:</p> <ul> <li><code>CHA</code> (default)</li> <li><code>RTA</code></li> <li><code>VTA</code></li> <li><code>SPARK</code></li> </ul> </li> <li> <p>--reportPath &lt;report_path&gt;</p> <p>Relative or absolute path for a directory to write the reports and visualization into.</p> </li> <li> <p>--reportFormat &lt;format1,format2,...&gt;</p> <p>The format(s) of the report. CogniCrypt<sub>SAST</sub> supports different formats to create an analysis report with the detected errors. Except the <code>CMD</code> value, all values require the <code>--reportPath</code> argument to be set. Multiple values can be concatenated by a comma (e.g. <code>CMD,TXT</code>). Possible values:</p> <ul> <li><code>CMD</code>: Prints a formatted output to <code>System.out</code> (default).</li> <li><code>TXT</code>: Creates a file <code>CryptoAnalysis-Report.txt</code> in the report path directory that contains a formatted output. The report is equivalent to the <code>CMD</code> output.</li> <li><code>SARIF</code>: Creates a file <code>CryptoAnalysis-Report.json</code> in the report path directory that is formatted in the SARIF 2.1 format.</li> <li><code>CSV</code>: Creates a file <code>CryptoAnalysis-Report.csv</code> in the report path directory that is formatted in the csv format.</li> <li><code>CSV_SUMMARY</code>: Creates a file <code>CryptoAnalysis-Report-Summary.csv</code> in the report path directory that is formatted in the csv format. Compared to the <code>CSV</code> option, this version contains only a summary of the analysis results, e.g. only the total numbers of each error type.</li> </ul> </li> <li> <p>--visualization</p> <p>Creates a file <code>visualization.png</code> in the report path directory that visualizes the connection of detected errors. This argument requires the <code>--reportPath</code> argument to be set.</p> </li> </ul>"},{"location":"android-scanner/#headlessandroidscanner-with-a-dependency","title":"HeadlessAndroidScanner with a dependency","text":"<p>CogniCrypt<sub>SAST</sub> provides a simple API that allows its usage inside a program. Its usage does not deviate from the CLI tool; for each argument, there is a corresponding <code>setter</code> method. Include the following dependency in your project and instantiate the <code>HeadlessJavaScanner</code>:</p> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;de.fraunhofer.iem&lt;/groupId&gt;\n    &lt;artifactId&gt;HeadlessAndroidScanner&lt;/artifactId&gt;\n    &lt;version&gt;x.y.z&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <p>You have two options to instantiate the <code>HeadlessAndroidScanner</code> and continue with its results:</p>"},{"location":"android-scanner/#instantiation-via-cli-structure","title":"Instantiation via CLI structure","text":"<p>A call to <code>createFromCLISettings(String[])</code> simulates the instantiation via the CLI. This can look like this: <pre><code>public class Example {\n\n    public static void main(String[] args) {\n        String[] myArgs = new String[] {\"--appPath\", \"path/to/app\", \"platformDirectory\", \"path/to/platforms\", \"--rulesDir\", \"path/to/rules\"};\n        HeadlessAndroidScanner scanner = HeadlessAndroidScanner.createFromCLISettings(myArgs);\n        scanner.run();\n\n        // Read the errors\n        Table&lt;WrappedClass, Method, Set&lt;AbstractError&gt;&gt; errors = scanner.getCollectedErrors();\n\n        // Continue with the collected errors\n    }\n}\n</code></pre></p>"},{"location":"android-scanner/#instantiation-via-constructor","title":"Instantiation via constructor","text":"<p>The <code>HeadlessAndroidScanner</code> has a public constructor that requires the required arguments: <pre><code>public class Example {\n\n    public static void main(String[] args) {\n        HeadlessJavaScanner scanner = new HeadlessJavaScanner(\"path/to/app\", \"path/to/platforms\", \"path/to/rules\");\n        scanner.setCallGraphAlgorithm(AndroidSettings.CallGraphAlgorithm.SPARK);\n        scanner.run();\n\n        // Read the errors\n        Table&lt;WrappedClass, Method, Set&lt;AbstractError&gt;&gt; errors = scanner.getCollectedErrors();\n\n        // Continue with the collected errors\n    }\n}\n</code></pre></p>"},{"location":"api/","title":"API of CryptoAnalysis","text":"<p>The <code>CryptoAnalysis</code> module contains the static analysis components. It allows the configuration of CogniCrypt<sub>SAST</sub> to match your own needs. The following example shows an alternative configuration with SootUp.</p>"},{"location":"api/#basic-example-idea","title":"Basic example idea","text":"<p>For research purposes, we are interested in the number of triggered Boomerang queries and the accumulated time to solve the queries. Thereby, we consider only SootUp as the underlying static analysis framework and <code>RTA</code> as the call graph algorithm.</p>"},{"location":"api/#including-the-dependencies","title":"Including the dependencies","text":"<p>Include the <code>HeadlessJavaScanner</code> module in your project:</p> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;de.fraunhofer.iem&lt;/groupId&gt;\n    &lt;artifactId&gt;HeadlessJavaScanner&lt;/artifactId&gt;\n    &lt;version&gt;x.y.z&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"api/#defining-a-listener","title":"Defining a listener","text":"<p><code>CryptoAnalysis</code> defines a set of listeners that are informed during the analysis. There are 3 types of listeners:</p> <ul> <li><code>IAnalysisListener</code>: Listener that tracks events during the analysis (e.g. the start of the typestate analysis, the analysis of seeds etc.)</li> <li><code>IResultsListener</code>: Listener that tracks intermediate analysis results (e.g. typestate analysis results, Boomerang query results etc.)</li> <li><code>IErrorListener</code>: Listener that tracks the report of detected errors</li> </ul> <p>Since we are interested in the starting and end points of solving Boomerang queries, we define an <code>IAnalysisListener</code> and consider the methods that are called when Boomerang queries are triggered:</p> <pre><code>public class QueryTrackingListener implements IAnalysisListener {\n\n    // Keep track of the triggered queries\n    private int triggeredQueries = 0;\n    // Watch to measure the accumulated time for each query\n    private Stopwatch watch = Stopwatch.createUnstarted();\n\n    public int getTriggeredQueries() {\n        return triggeredQueries;\n    }\n\n    public String getWatchTime() {\n        return watch.toString();\n    }\n\n    @Override\n    public void beforeTriggeringBoomerangQuery(BackwardQuery query) {\n        watch.start();\n    }\n\n    @Override\n    public void afterTriggeringBoomerangQuery(BackwardQuery query) {\n        watch.stop();\n        triggeredQueries++;\n    }\n}\n</code></pre>"},{"location":"api/#set-up-and-run-the-headlessjavascanner","title":"Set up and run the HeadlessJavaScanner","text":"<p>We can use the API of the <code>HeadlessJavaScanner</code> to configure CogniCrypt<sub>SAST</sub> to run with our own listener:</p> <pre><code>public class BoomerangQueryTracking {\n\n    public static void main(String[] args) {\n        HeadlessJavaScanner scanner = new HeadlessJavaScanner(\"path/to/app\", \"path/to/rules\");\n\n        // We are only interested in SootUp with RTA\n        scanner.setFramework(ScannerSettings.Framework.SootUp);\n        scanner.setCallGraphAlgorithm(ScannerSettings.CallGraphAlgorithm.RTA);\n\n        // We do not need a report\n        scanner.setReportFormats(Collections.emptySet());\n\n        // Add our own listener\n        QueryTrackingListener listener = new QueryTrackingListener();\n        scanner.addAnalysisListener(listener);\n\n        // Run the scanner and print the results\n        scanner.run();\n        System.out.println(\"Triggered Boomerang queries: \" + listener.getTriggeredQueries());\n        System.out.println(\"Time for solving all queries: \" + listener.getWatchTime());\n    }\n}\n</code></pre>"},{"location":"contributing/","title":"Contributing","text":"<p>We hare happy for every contribution from the community! Please consider the following aspects when contributing to this project.</p>"},{"location":"contributing/#coding-guidelines","title":"Coding Guidelines","text":"<p>We aim for keeping the code as clean as possible. To do so, we follow the Google style guide for Java/Android. To format the code, run the command</p> <pre><code>mvn spotless:apply\n</code></pre> <p>before committing your changes.</p>"},{"location":"contributing/#workflow","title":"Workflow","text":"<p>We aim for the following workflow:</p> <p>1) Create a fork from this repository</p> <p>2) Create a new branch and push your changes to it</p> <p>3) Open a pull request against the <code>develop</code> branch from this repository</p> <ul> <li>The pull request should contain a small description of the changes and why they are needed</li> </ul> <p>4) Wait for a review or approval</p> <p>When adding your changes, please make sure that all tests are passing. We have corresponding GitHub actions that check whether there are any problems. You can also check the status locally (see Installation and Setup).</p>"},{"location":"contributing/#branches","title":"Branches","text":"<p>This repository contains two central branches. The master and the develop branch. The <code>develop</code> branch is default. Both branches are protected against direct write access, thus Pull Requests are necessary to push into them. Other branches are unprotected and can be created and deleted by a contributor</p> <p>The <code>master</code> branch holds the latest stable release of the application.</p> <p>The <code>develop</code> branch holds the latest development version of the application.</p> <p>New branches should always target <code>develop</code>. Once, we decide to release a new version, we merge the changes from the <code>develop</code> branch into the <code>master</code> branch and deploy the changes to Maven Central.</p>"},{"location":"contributing/#branching","title":"Branching","text":"<p>Since <code>master</code> and <code>develop</code> branches are protected, working with branches is mandatory.</p> <p>In general, each branch shall only be responsible for one idea. This way we try to minimize the amount of changes in all branches, which makes it easier to review.</p>"},{"location":"contributing/#naming-branches","title":"Naming Branches","text":"<p>Branch names should be declarative, meaning the name of a branch shall always yield what it's ultimately going to change. Since a branch can target different aspects of development (e.g. feature, bug-fix, refactoring, etc.) their names shall have that information also included by adding a PREFIX. The scheme of a branch name look as follows: <code>PREFIX/tell-what-it-does</code></p> <p>For example, we suggest the following prefixes:</p> <pre><code>feature/    // For new features\nfix/        // Fixes a bug\n</code></pre>"},{"location":"error-types/","title":"Error Types","text":"<p>CryptoAnalysis reports various kinds of errors that violate the sections in a CrySL rule. On this page, we give an overview and examples of the different error types. Note that the examples contain simple rules and programs to emphasize the concrete violation, they may not be part of the actual ruleset.</p>"},{"location":"error-types/#general-information","title":"General information","text":"<p>CryptoAnalysis operates on an intermediate representation (three address code) of the original code. Therefore, the reported statements may be simplified and variable names may differ. To compensate for these deviations, CryptoAnalysis reports among the error types the classes, statements and line numbers of the error location. Hence, one should be able to find the exact error locations in the original code.</p> <p>Additionally, CryptoAnalysis performs small transformations on the original code. Primarily, this step includes extracting direct parameters into multiple statements. For example, the statement</p> <pre><code>KeyGenerator kg = KeyGenerator.getInstance(\"AES\", \"BC\");\n</code></pre> <p>is transformed to</p> <pre><code>varReplacer0 = \"AES\";\nvarReplacer1 = \"BC\";\nkg = KeyGenerator.getInstance(varReplacer0, varReplacer1);\n</code></pre> <p>Depending on the error type, CryptoAnalysis may report an error at the first two statements, although these statements do not exist in this form in the original code. Using the reported line numbers, one can map the statement to the original statement because the line numbers are kept from the original code. These transformations can be identified by the <code>varReplacer</code> name.</p>"},{"location":"error-types/#constrainterror","title":"ConstraintError","text":"<p>CryptoAnalysis reports a <code>ConstraintError</code> if a constraint from the <code>CONSTRAINTS</code> section is violated. For example, consider the following rule <code>KeyGenerator.crysl</code>: <pre><code>SPEC javax.crypto.KeyGenerator\n\nOBJECTS\n    java.lang.String algorithm;\n    int keySize;\n\nEVENTS\n    Ins: getInstance(algorithm);\n    Init: init(keySize);\n\nCONSTRAINTS\n    algorithm in {\"AES\"} =&gt; keySize in {128, 256};\n</code></pre> and the following program that violates the constraint <pre><code>public class ConstraintErrorExample {\n\n    public static void main(String[] args) {\n        KeyGenerator keyGen = KeyGenerator.getInstance(\"AES\");\n        keyGen.init(64); // Key size of 64 is not allowed\n    }\n}\n</code></pre> CryptoAnalysis reports a <code>ConstraintError</code> indicating that the constraint from the rule is violated. Note that the constraint is evaluated as a logical expression <code>A =&gt; B</code> that is violated when <code>A</code> is satisfied and <code>B</code> is violated. Depending on the constraints and the logical expressions, the error messages may vary.</p>"},{"location":"error-types/#forbiddenmethoderror","title":"ForbiddenMethodError","text":"<p>CryptoAnalysis reports a ForbiddenMethodError if there is a call to method from the FORBIDDEN section. For example, consider the following rule <code>PBEKeySpec.crysl</code>: <pre><code>SPEC javax.crypto.spec.PBEKeySpec\n\nFORBIDDEN\n    PBEKeySpec(char[]);\n</code></pre> and the program <pre><code>public class ForbiddenMethodErrorExample {\n\n    public static void main(String[] args) {\n        byte[] password = new byte[]{'p', 'w', 'd'};\n        PBEKeySpec spec = new PBEKeySpec(password); // This constructor call is forbidden\n    }\n}\n</code></pre> CryptoAnalysis reports a <code>ForbiddenMethodError</code> because the rule does not allow the call to the constructor that has only <code>char[]</code> as parameter.</p>"},{"location":"error-types/#imprecisevalueextractionerror","title":"ImpreciseValueExtractionError","text":"<p>CryptoAnalysis reports an <code>ImpreciseValueExtractionError</code> if it is not able to extract required information to evaluate constraints from the <code>CONSTRAINTS</code> section. For example, consider the following rule <code>KeyGenerator.crysl</code>: <pre><code>SPEC javax.crypto.KeyGenerator\n\nOBJECTS\n    java.lang.String algorithm;\n\nEVENTS\n    Con: getInstance(algorithm);\n\nCONSTRAINTS\n    algorithm in {\"AES\"};\n</code></pre> and the program <pre><code>public class ImpreciseValueExtractionError {\n\n    public static void main(String[] args) {\n        String alg = readFromInput(); // Assumption: readFromInput() returns some dynamic input\n        KeyGenerator keyGen = KeyGenerator.getInstance(alg);\n    }\n}\n</code></pre></p> <p>CryptoAnalysis reports a <code>ImpreciseValueExtractionError</code> for the constraint <code>algorithm in {\"AES\"}</code> because it cannot statically evaluate the return value of <code>readFromInput()</code>.</p>"},{"location":"error-types/#incompleteoperationerror","title":"IncompleteOperationError","text":"<p>CryptoAnalysis reports an <code>IncompleteOperationError</code> if the operations in the <code>ORDER</code> sections are not completed. For example, consider the following rule <code>KeyGenerator.crysl</code>: <pre><code>SPEC javax.crypto.KeyGenerator\n\nEVENTS\n    Con: getInstance(_);\n    Init: init(_);\n    Gen: generateKey();\n\nORDER\n   Con, Init, Gen\n</code></pre> and the program <pre><code>public class IncompleteOperationErrorExample {\n\n    public static void main(String[] args) {\n        KeyGenerator kg = KeyGenerator.getInstance(\"AES\");\n        kg.init(128);\n    }\n}\n</code></pre> CryptoAnalysis reports an <code>IncompleteOperationError</code> because a call to <code>generateKey()</code> is missing to complete the sequence of operations in the <code>ORDER</code> section. In this example, the incomplete operation renders the code dead because the <code>KeyGenerator</code> is initialized but not used.</p>"},{"location":"error-types/#typestateerror","title":"TypestateError","text":"<p>CryptoAnalysis reports a <code>TypestateError</code> if the order of operations in the <code>ORDER</code> section is violated. For example, consider the following rule <code>KeyGenerator.crysl</code>: <pre><code>SPEC javax.crypto.KeyGenerator\n\nEVENTS\n    Con: getInstance(_);\n    Init: init(_);\n    Gen: generateKey();\n\nORDER\n    Con, Init, Gen\n</code></pre> and the program <pre><code>public class TypestateErrorExample {\n\n    public static void main(String[] args) {\n        KeyGenerator kg = KeyGenerator.getInstance(\"AES\"); // Con\n        // Missing call to kg.init(...)\n        Key key = kg.generateKey(); // Gen\n    }\n}\n</code></pre> CryptoAnalysis reports a <code>TypestateError</code> because the call sequence misses the event <code>Init</code> that is defined with a call to <code>init(...)</code>.</p>"},{"location":"error-types/#requiredpredicateerror","title":"RequiredPredicateError","text":"<p>CryptoAnalysis reports a <code>RequiredPredicateError</code> if a predicate from the <code>REQUIRES</code> section is not ensured. For example, consider the following rules <code>KeyGenerator.crysl</code> <pre><code>SPEC javax.crypto.KeyGenerator\n\nOBJECTS\n    java.lang.String algorithm;\n    java.security.Key key;\n\nEVENTS\n    Con: getInstance(algorithm);\n    Gen: key = generateKey(); // Define the return value from the call to generateKey()\n\nORDER\n    Con, Gen\n\nCONSTRAINTS\n    algorithm in {\"AES\"};\n\nENSURES\n    generatedKey[key]; // If the KeyGenerator is secure, it ensures the predicate 'generatedKey' on the returned value 'key'\n</code></pre> and <code>Key.crysl</code> <pre><code>SPEC java.security.Key\n\nREQUIRES\n    generatedKey[this]; // A key requires the predicate 'generatedKey' when it is instantiated (this)\n</code></pre> and the program <pre><code>public class RequiredPredicateErrorExample {\n\n    public static void main(String[] args) {\n        KeyGenerator kg = KeyGenerator.getInstance(\"DES\"); // \"DES\" causes a ConstraintError, i.e. the rule is violated and kg not secure and cannot ensure any predicates\n        Key key = kg.generateKey(); // kg does not ensure a predicate on the key such that the required predicate 'generatedKey' is violated in the rule Key.crysl\n    }\n}\n</code></pre> CryptoAnalysis reports a <code>RequiredPredicateError</code> because the algorithm DES is not allowed such that the rule for the KeyGenerator is violated and kg is not secure. Therefore, kg does not ensure any predicates which violates the <code>REQUIRES</code> section from the rule <code>Key.crysl</code>. Note that CryptoAnalysis also reports a <code>ConstraintError</code> for the violated algorithm constraint and connects it to the <code>RequiredPredicateError</code>. In this scenario, the <code>ConstraintError</code> causes the <code>RequiredPredicateError</code> and we have the following connection:</p> <p></p> <p>Note that CryptoAnalysis operates on the intermediate representation of the original program code. Hence, the variable names may differ. In this case, <code>l1</code> corresponds <code>kg</code> and <code>l2</code> corresponds to <code>key</code>.</p>"},{"location":"error-types/#alternativerequiredpredicateerror","title":"AlternativeRequiredPredicateError","text":"<p>CryptoAnalysis reports an <code>AlternativeRequiredPredicateError</code> if a predicate with alternatives from the <code>REQUIRES</code> section is not ensured. Conceptually, this error is the same as a <code>RequiredPredicateError</code>. The difference is that CryptoAnalysis reports an <code>AlternativeRequiredPredicateError</code> if no alternatives are ensured. For example, we have the following rule <code>Cipher.crysl</code> <pre><code>SPEC javax.crypto.Cipher\n\nOBJECTS\n    java.security.Key key;\n\nEVENTS\n    Con: getInstance(_);\n    Init: init(_, key);\n\nREQUIRES\n    generatedKey[key] || generatedPubKey[key] || generatedPrivKey[key]; // Alternatives: key is a (symmetric) key, public key or private key\n</code></pre> An <code>AlternativePredicateError</code> indicates that no alternative is ensured, i.e. a given key is not a correctly generated symmetric, public or private key.</p>"},{"location":"examples/","title":"Example Analysis","text":"<p>To show how CogniCrypt<sub>SAST</sub> works, we consider the following code example:</p> <pre><code>import java.security.GeneralSecurityException;\nimport javax.crypto.KeyGenerator;\nimport javax.crypto.SecretKey;\nimport javax.crypto.spec.SecretKeySpec;\nimport javax.crypto.Cipher;\n\npublic class Example {\n\n    public static void main(String[] args) throws GeneralSecurityException {\n        // \"DES\" is not allowed -&gt; ConstraintError\n        KeyGenerator generator = KeyGenerator.getInstance(\"DES\"); // l1\n\n        // Key size of 64 is not allowed -&gt; ConstraintError\n        generator.init(64);\n\n        // KeyGenerator is not correctly initialized. Hence, the generated\n        // key is not secure -&gt; RequiredPredicateError\n        SecretKey key = generator.generateKey(); // l2\n\n        // \"DES\" is not allowed -&gt; ConstraintError\n        Cipher cipher = Cipher.getInstance(\"DES\"); // l3\n\n        // \"key\" is not securely generated -&gt; RequiredPredicateError\n        cipher.init(Cipher.ENCRYPT_MODE, key);\n\n        // Cipher object is initialized but not used for encryption -&gt; IncompleteOperationError\n    }\n}\n</code></pre> <p>Using the JCA rules, we can use the <code>HeadlessJavaScanner</code> to analyze the compiled version of this program:</p> <p><pre><code>java -jar HeadlessJavaScanner-x.y.z-jar-with-dependencies.jar \\\\\n               --appPath ./Example.jar \\\\\n               --rulesDir ./JCA-CrySL-rules.zip \\\\\n               --framework Soot \\\\\n               --reportFormat CMD \\\\\n               --reportPath ./output/ \\\\\n               --visualization\n</code></pre> Observe that we use <code>Soot</code> as the underlying analysis framework, we print the report to the command line, and we enable the visualization. CogniCrypt<sub>SAST</sub> runs the analysis and reports 3 ConstraintErrors, 2 RequiredPredicateErrors and 1 IncompleteOperationError, and their positions in the original programs. Additionally, since we use <code>--visualization</code>, it creates the following image <code>visualization.png</code> in the directory <code>./output/</code>:</p> <p></p> <p>You can see that two ConstraintErrors on the object <code>l1</code> (KeyGenerator) cause a RequiredPredicateError on the object <code>l2</code> (SecretKey) which in turn causes a RequiredPredicateError on the object <code>l3</code> (Cipher). Additionally, there is another ConstraintError and IncompleteOperationError on the Cipher object. Note that the variables and statements correspond to the intermediate representation Jimple. You can match the variables to the command line output that lists all analyzed objects.</p>"},{"location":"installation/","title":"Installation and Setup","text":""},{"location":"installation/#building-the-project","title":"Building the project","text":"<p>CogniCrypt<sub>SAST</sub> uses Maven as build tool. You can compile this project and build the executable <code>jar</code> files via the command <pre><code>mvn clean package -DskipTests\n</code></pre> The packaged <code>jar</code> artefacts including all dependencies can be found in the created <code>/apps</code> directory. Building requires at least Java 17.</p>"},{"location":"installation/#including-the-project-as-dependency","title":"Including the project as dependency","text":"<p>You can find CogniCrypt<sub>SAST</sub> on Maven Central. Depending on your use case, include the following dependencies in your project (replace <code>x.y.z</code> with the most recent version):</p> <p>CryptoAnalysis and its scopes: <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;de.fraunhofer.iem&lt;/groupId&gt;\n    &lt;artifactId&gt;CryptoAnalysis&lt;/artifactId&gt;\n    &lt;version&gt;x.y.z&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;de.fraunhofer.iem&lt;/groupId&gt;\n    &lt;artifactId&gt;CryptoAnalysis-Scopes&lt;/artifactId&gt;\n    &lt;version&gt;x.y.z&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> HeadlessJavaScanner: <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;de.fraunhofer.iem&lt;/groupId&gt;\n    &lt;artifactId&gt;HeadlessJavaScanner&lt;/artifactId&gt;\n    &lt;version&gt;x.y.z&lt;/version&gt;\n&lt;/dependency&gt; \n</code></pre> HeadlessAndroidScanner: <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;de.fraunhofer.iem&lt;/groupId&gt;\n    &lt;artifactId&gt;HeadlessAndroidScanner&lt;/artifactId&gt;\n    &lt;version&gt;x.y.z&lt;/version&gt;\n&lt;/dependency&gt; \n</code></pre></p>"},{"location":"installation/#use-as-a-github-action","title":"Use as a GitHub action","text":"<p>CogniCrypt<sub>SAST</sub> can be used as a GitHub action.</p> <p><pre><code>- name: Run CogniCrypt\n  uses: CROSSINGTUD/CryptoAnalysis@&lt;version&gt;\n  with:\n    appPath: \"CryptoAnalysisTargets/HelloWorld/HelloWorld.jar\"\n    basePath: \"CryptoAnalysisTargets/HelloWorld\"\n</code></pre> The <code>appPath</code> needs to be configured to point to a compiled version of your application.</p> <p>The <code>basePath</code> is used to relate paths in the analyzed jar and the source tree. Class <code>com.example</code> is searched for at <code>basePath/com/example</code>.</p> <p>See action.yml for all input options.</p> <p>An example of how to use the GitHub action can be found in the CryptoAnalysis-demo repository.</p>"},{"location":"installation/#running-tests","title":"Running tests","text":"<p>The project is configured to run the tests in each module and for each framework separately. If you plan to run the tests, use the following commands:</p> <ul> <li>Test CryptoAnalysis: <code>mvn clean verify -f CryptoAnalysis -DtestSetup=&lt;framework&gt;</code></li> <li>Test the HeadlessJavaScanner: <code>mvn clean verify -f HeadlessJavaScanner -DtestSetup=&lt;framework&gt;</code></li> <li>Test the HeadlessAndroidScanner: <code>mvn clean verify -f HeadlessAndroidScanner -DtestSetup=FlowDroid</code></li> </ul> <p>Replace <code>&lt;framework&gt;</code> with <code>Soot</code>, <code>SootUp</code> or <code>Opal</code> to run the tests with the corresponding underlying framework.</p>"},{"location":"java-scanner/","title":"CogniCrypt<sub>SAST</sub> for Java Applications","text":"<p>The <code>HeadlessJavaScanner</code> implements an interface for CogniCrypt<sub>SAST</sub> that allows the analysis of Java applications. You can use it as an CLI tool or run it programmatically with a dependency.</p>"},{"location":"java-scanner/#headlessjavascanner-as-cli-tool","title":"HeadlessJavaScanner as CLI tool","text":"<p>CogniCrypt<sub>SAST</sub> can be started as CLI tool via the file <code>HeadlessJavaScanner-x.y.z-jar-with-dependencies.jar</code>. You can build this file yourself (see the installation) or download the last released version from the GitHub releases. The following list explains required and optional CLI options. See the examples for concrete use cases</p>"},{"location":"java-scanner/#required-arguments","title":"Required arguments","text":"<p>The HeadlessJavaScanner requires two arguments:</p> <ul> <li> <p>--appPath &lt;path_to_app&gt;</p> <p>The path of the application to be analyzed (.jar file or the root compilation output folder which contains the .class files in subdirectories).</p> </li> <li> <p>--rulesDir &lt;path_to_rules&gt;</p> <p>The path to the directory of the CrySL (source code format) rule files. The scanner supports basic directories and zip files. The source code for the rules can be found here.</p> </li> </ul>"},{"location":"java-scanner/#optional-arguments","title":"Optional arguments","text":"<ul> <li> <p>--framework &lt;framework&gt;</p> <p>The underlying static analysis framework. The framework is used to read the target application and construct the call graph. Possible values:</p> <ul> <li><code>Soot</code>: Use Soot as the underlying framework (default)</li> <li><code>SootUp</code>: Use SootUp as the underlying framework</li> <li><code>Opal</code>: Use Opal as the underlying framework</li> </ul> </li> <li> <p>--cg &lt;call_graph&gt;</p> <p>The call graph algorithm to construct the call graph for the analysis. Note that depending on the selected framework, the available algorithms differ. For each framework, <code>CHA</code> is the default algorithm. Possible values:</p> Framework Call Graph Algorithms Soot CHA, RTA, VTA, SPARK, SPARK_LIB SootUp CHA, RTA Opal CHA, RTA, AllocSiteBased </li> <li> <p>--addClassPath &lt;addClassPath&gt;</p> <p>Extend the current classpath the given classpath. This option is relevant if you have rules for classes that are not on the current classpath.</p> </li> <li> <p>--reportPath &lt;report_path&gt;</p> <p>Relative or absolute path for a directory to write the reports and visualization into.</p> </li> <li> <p>--reportFormat &lt;format1,format2,...&gt;</p> <p>The format(s) of the report. CogniCrypt<sub>SAST</sub> supports different formats to create an analysis report with the detected errors. Except the <code>CMD</code> value, all values require the <code>--reportPath</code> argument to be set. Multiple values can be concatenated by a comma (e.g. <code>CMD,TXT</code>). Possible values:</p> <ul> <li><code>CMD</code>: Prints a formatted output to <code>System.out</code> (default).</li> <li><code>TXT</code>: Creates a file <code>CryptoAnalysis-Report.txt</code> in the report path directory that contains a formatted output. The report is equivalent to the <code>CMD</code> output.</li> <li><code>SARIF</code>: Creates a file <code>CryptoAnalysis-Report.json</code> in the report path directory that is formatted in the SARIF 2.1 format.</li> <li><code>CSV</code>: Creates a file <code>CryptoAnalysis-Report.csv</code> in the report path directory that is formatted in the csv format.</li> <li><code>CSV_SUMMARY</code>: Creates a file <code>CryptoAnalysis-Report-Summary.csv</code> in the report path directory that is formatted in the csv format. Compared to the <code>CSV</code> option, this version contains only a summary of the analysis results, e.g. only the total numbers of each error type.</li> </ul> </li> <li> <p>--visualization</p> <p>Creates a file <code>visualization.png</code> in the report path directory that visualizes the connection of detected errors. This argument requires the <code>--reportPath</code> argument to be set.</p> </li> <li> <p>--ignoreSections &lt;path_to_file&gt;</p> <p>Names of packages, classes and methods to be ignored during the analysis. This argument expects path to a file containing one name per line. This option may be useful if a larger section of the program should not be analyzed because they do not contain cryptographic operations. For example, in the following program <pre><code>public class Example {\n    public String queryDatabase(String query) {\n        ...\n    }\n\n    public void encryptDatabaseValues(String query) {\n        // Querying the database may contain much logic without cryptographic operations, so we should exclude it\n        String queryResult = queryDatabase(query);\n\n        // Encrypt the query result\n        Cipher cipher = Cipher.getInstance(\"AES\");\n        ...\n    }\n}\n</code></pre> we query a database and encrypt the query result. However, as the developer, we know that the call to <code>queryDatabase</code> contains a lot of logic, but no relevant cryptographic operations. Hence, we can use a file</p> <pre><code>example.Example.queryDatabase\n</code></pre> <p>to avoid analyzing dataflows within this method. In general, the argument allows the exclusion of packages, classes and methods:</p> <ul> <li>Method: The name of the method to be excluded. The format is <code>&lt;fully_qualified_class_name&gt;.&lt;method_name&gt;</code>.</li> <li>Class: The fully qualified name of the class. This excludes the dataflow within all methods in the class.</li> <li>Package: The name of a package. This excludes the dataflow within all classes in the package. Use <code>*</code> excludes all classes and subpackages (e.g. <code>de.example.*</code>).</li> </ul> </li> <li> <p>--timeout &lt;timeout&gt;</p> <p>A timeout in milliseconds for Boomerang queries. In rare cases, Boomerang queries may require a lot of time to finish the pointer analysis. Using this argument allows the abortion of queries after some time. By default, no timeout is used.</p> </li> </ul>"},{"location":"java-scanner/#headlessjavascanner-with-a-dependency","title":"HeadlessJavaScanner with a dependency","text":"<p>CogniCrypt<sub>SAST</sub> provides a simple API that allows its usage inside a program. Its usage does not deviate from the CLI tool; for each argument, there is a corresponding <code>setter</code> method. Include the following dependency in your project and instantiate the <code>HeadlessJavaScanner</code>:</p> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;de.fraunhofer.iem&lt;/groupId&gt;\n    &lt;artifactId&gt;HeadlessJavaScanner&lt;/artifactId&gt;\n    &lt;version&gt;x.y.z&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <p>You have two options to instantiate the <code>HeadlessJavaScanner</code> and continue with its results:</p>"},{"location":"java-scanner/#instantiation-via-cli-structure","title":"Instantiation via CLI structure","text":"<p>A call to <code>createFromCLISettings(String[])</code> simulates the instantiation via the CLI. This can look like this: <pre><code>public class Example {\n\n    public static void main(String[] args) {\n        String[] myArgs = new String[] {\"--appPath\", \"path/to/app\", \"--rulesDir\", \"path/to/rules\"};\n        HeadlessJavaScanner scanner = HeadlessJavaScanner.createFromCLISettings(myArgs);\n        scanner.run();\n\n        // Get the errors\n        Table&lt;WrappedClass, Method, Set&lt;AbstractError&gt;&gt; errors = scanner.getCollectedErrors();\n\n        // Continue with the collected errors\n    }\n}\n</code></pre></p>"},{"location":"java-scanner/#instantiation-via-constructor","title":"Instantiation via constructor","text":"<p>The <code>HeadlessJavaScanner</code> has a public constructor that requires the required arguments: <pre><code>public class Example {\n\n    public static void main(String[] args) {\n        HeadlessJavaScanner scanner = new HeadlessJavaScanner(\"path/to/app\", \"path/to/rules\");\n        // Some more configuration\n        scanner.setFramework(ScannerSettings.Framework.SootUp);\n        scanner.setCallGraphAlgorithm(ScannerSettings.CallGraphAlgorithm.RTA);\n        scanner.run();\n\n        // Get the errors\n        Table&lt;WrappedClass, Method, Set&lt;AbstractError&gt;&gt; errors = scanner.getCollectedErrors();\n\n        // Continue with the collected errors\n    }\n}\n</code></pre></p>"}]}